"""Plan:X 1) read in a .data file - via argparseX 2) establish number of atoms (in line 3)X 3) go to coordinates...    - loop over natoms-1 other atoms somehow    - https://stackoverflow.com/questions/44080904/looping-through-all-item-except-itself/44081011    - if distance (via pythag) to another is < cutoff, count=count+1    - generate .dat table to look like atom_id || no of nearest neighbours"""import argparseimport numpy as npparser = argparse.ArgumentParser(    description="Read a LAMMPS .data file and count for nearest neighbours.")parser.add_argument(    "--file",    type=str,    help="The .data file to read.",)args = parser.parse_args()def retrieve_data(data_file, coordinates, boxsize):    with open(f"{data_file}", "r") as df:        lines = df.readlines()    natoms = int((lines[2].split())[0])    boxsize += (float((lines[5].split())[1]),                float((lines[6].split())[1]),                float((lines[7].split())[1]))    for i in range(1, natoms+1):        # atom_id = float((lines[i+14].split())[0])        xcoord = float((lines[i+14].split())[2])        ycoord = float((lines[i+14].split())[3])        zcoord = float((lines[i+14].split())[4])        fullcoord = ([xcoord, ycoord, zcoord])        coordinates.append(fullcoord)    return coordinates, boxsizedef pythagoras(coord1, coord2):    distance = np.sqrt((coord2[0]-coord1[0])**2+(coord2[1]-coord1[1])**2+(coord2[2]-coord1[2])**2)    return distancedef reduce_coordinates(full_coordinates, boxsize, cutoff):    xbounds = [0 + cutoff, boxsize[0] - cutoff]    ybounds = [0 + cutoff, boxsize[1] - cutoff]    zbounds = [0 + cutoff, boxsize[2] - cutoff]    reduced_coordinates = []    for coord in full_coordinates:        if xbounds[0] < coord[0] < xbounds[1] and ybounds[0]<coord[1]<ybounds[1] and zbounds[0]<coord[2]<zbounds[1]:              reduced_coordinates.append(coord)    return reduced_coordinatesdef distance_check(reduced_coordinates, full_coordinates, cutoff, boxsize):    data = []    for i, coord1 in enumerate(reduced_coordinates):        count = 0        for coord2 in full_coordinates:            distance = pythagoras(coord1, coord2)            if coord1 == coord2:                continue            if distance < cutoff:                count = count + 1        data.append([i, count])    return datadef create_histogram_table(data):    results_table = []    for i in [0, 1, 2, 3, 4, 5, 6]:        count = 0        for element in data:            if element[1] == i:                count = count + 1        results_table.append([i, count])    with open(f"{args.file[0:-5]}_coord_distr.dat", "x") as hist:        hist.write("coord_no frequency\n")        for item in results_table:            hist.write("{} {}\n".format(*item))# Maincutoff = 1.6full_coordinates = []boxsize = ()full_coordinates, boxsize = retrieve_data(args.file, full_coordinates, boxsize)reduced_coordinates = reduce_coordinates(full_coordinates, boxsize, cutoff)data = distance_check(reduced_coordinates, full_coordinates, cutoff, boxsize)create_histogram_table(data)